
# JavaScript Basics (Prerequisite for React)

## Step 1: Variables (let and const)

Variables store data.

### let → value can change
```js
let age = 20;
age = 21; // allowed
````

### const → value cannot be reassigned

```js
const name = "Varun";
// name = "Rahul"; ❌ Error
```

Use **const by default**. Use **let only when the value needs to change**.

---

## Step 2: Functions

Functions are reusable blocks of code.

### Normal Function

```js
function greet(name) {
  return "Hello " + name;
}

console.log(greet("Varun"));
```

### Arrow Function (Modern Way)

```js
const greet = (name) => {
  return "Hello " + name;
};
```

### Short Arrow Function

```js
const greet = name => "Hello " + name;
```

---

## Step 3: Arrays

Arrays store multiple values.

```js
const fruits = ["Apple", "Mango", "Banana"];
console.log(fruits[0]); // Apple
```

### Important Array Methods

#### map() → transform each item

```js
const numbers = [1, 2, 3];

const doubled = numbers.map(num => num * 2);
console.log(doubled); // [2, 4, 6]
```

#### filter() → keep items that match a condition

```js
const ages = [12, 18, 25, 10];

const adults = ages.filter(age => age >= 18);
console.log(adults); // [18, 25]
```

#### reduce() → combine into one value

```js
const numbers = [1, 2, 3, 4];

const sum = numbers.reduce((total, num) => total + num, 0);
console.log(sum); // 10
```

---

## Step 4: Objects

Objects store data in key–value pairs.

```js
const person = {
  name: "Varun",
  age: 25,
  city: "Delhi"
};

console.log(person.name); // Varun
```

### Destructuring (Extract values easily)

```js
const person = { name: "Varun", age: 25 };

const { name, age } = person;

console.log(name); // Varun
console.log(age);  // 25
```

---

## Step 5: Spread Operator (...)

Used to copy or merge arrays/objects.

### Copy an array

```js
const arr1 = [1, 2];
const arr2 = [...arr1, 3, 4];

console.log(arr2); // [1, 2, 3, 4]
```

### Copy an object

```js
const user = { name: "Varun" };
const updatedUser = { ...user, age: 25 };

console.log(updatedUser);
```

---

## Step 6: ES6 Modules (import / export)

Used to split code into multiple files.

### In `math.js`

```js
export const add = (a, b) => a + b;
```

### In `app.js`

```js
import { add } from "./math.js";

console.log(add(2, 3));
```

---

## Step 7: Promises

Promises handle future results (like API calls).

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Data received");
  }, 2000);
});

promise.then(result => console.log(result));
```

### Promise States

* Pending
* Resolved
* Rejected

---

## Step 8: Async / Await (Better way to use Promises)

```js
const fetchData = async () => {
  return "Data loaded";
};

const getData = async () => {
  const result = await fetchData();
  console.log(result);
};

getData();
```

### With real API

```js
const getUsers = async () => {
  const response = await fetch("https://jsonplaceholder.typicode.com/users");
  const data = await response.json();
  console.log(data);
};
```









# Classes and Objects in JavaScript

## What is a Class?

A **class** is a blueprint for creating objects.
It defines the **properties (data)** and **methods (functions)** that the objects created from it will have.

Example from real life:
Blueprint of a house → Many houses can be built from it.

---

## Creating a Class

```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(`Hi, I'm ${this.name} and I'm ${this.age} years old.`);
  }
}
```

### constructor()

* A special method inside a class
* Automatically runs when a new object is created
* Used to initialize object properties

---

## Creating Objects (Instances)

Objects created from a class are called **instances**.

```javascript
const person1 = new Person("Varun", 25);
const person2 = new Person("Amit", 30);
```

---

## Using Object Methods

```javascript
person1.greet(); // Hi, I'm Varun and I'm 25 years old.
person2.greet(); // Hi, I'm Amit and I'm 30 years old.
```

---

## Understanding the Relationship

| Class (Blueprint) | Object (Instance) |
| ----------------- | ----------------- |
| Person            | person1, person2  |
| name, age         | "Varun", 25       |
| greet()           | person1.greet()   |

---

## Adding More Methods

```javascript
class Car {
  constructor(brand, year) {
    this.brand = brand;
    this.year = year;
  }

  start() {
    console.log(`${this.brand} car started`);
  }

  getAge(currentYear) {
    return currentYear - this.year;
  }
}

const myCar = new Car("Toyota", 2020);
myCar.start(); 
console.log(myCar.getAge(2026)); 
```

---

## Class Inheritance

Inheritance allows one class to use properties and methods of another class.

```javascript
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a a sound`);
  }
}

class Dog extends Animal {
  bark() {
    console.log(`${this.name} barks`);
  }
}

const dog1 = new Dog("Tommy");
dog1.speak(); 
dog1.bark();  
```

---

## Using super()

When a child class defines its own constructor, it must call `super()` to access the parent class constructor.

```javascript
class Dog extends Animal {
  constructor(name, breed) {
    super(name); 
    this.breed = breed;
  }
}
```

---

## Real-Life Example

```javascript
class Student {
  constructor(name, marks) {
    this.name = name;
    this.marks = marks;
  }

  isPassed() {
    return this.marks >= 40;
  }
}

const s1 = new Student("Riya", 75);
console.log(s1.isPassed()); 
```

---

## Key Concepts Summary

* **Class** → Blueprint for objects
* **Object** → Instance of a class
* **constructor()** → Initializes values
* **this** → Refers to the current object
* **new** → Creates a new object
* **extends** → Used for inheritance
* **super()** → Calls parent class constructor

---
